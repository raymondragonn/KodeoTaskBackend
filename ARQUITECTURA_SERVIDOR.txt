================================================================================
                    ARQUITECTURA DEL SERVIDOR KODEOTASK
================================================================================

Este documento explica cómo funciona la autenticación, TCP, UDP y el propósito
de cada archivo Java en el servidor backend.

================================================================================
                          1. AUTENTICACIÓN
================================================================================

La autenticación funciona mediante tokens JWT-like (simplificado) que se 
generan después del login exitoso.

FLUJO DE AUTENTICACIÓN:

1. REGISTRO (POST /api/auth/register):
   - El usuario envía: username, email, password, firstName, lastName
   - AuthService valida que el username y email no existan
   - La contraseña se hashea con SHA-256 + salt usando PasswordUtil
   - Se crea el usuario en la base de datos mediante UserDAO
   - Retorna éxito o error

2. LOGIN (POST /api/auth/login):
   - El usuario envía: username y password
   - AuthService busca el usuario por username en la base de datos
   - Se verifica la contraseña usando PasswordUtil.verifyPassword()
   - Si es correcta, se genera un token usando TokenUtil.generateToken()
   - El token contiene: userId, username, expiration y una firma
   - El token se codifica en Base64 y se retorna al cliente
   - El token tiene duración de 24 horas

3. VALIDACIÓN DE TOKEN:
   - Cada petición HTTP debe incluir el header: Authorization: Bearer <token>
   - TCPClientHandler extrae el token del header
   - TokenUtil.validateToken() verifica:
     * Que el token esté en formato válido
     * Que no haya expirado
     * Que la firma sea correcta
   - Si es válido, retorna el userId
   - Si es inválido, retorna 401 Unauthorized

4. SEGURIDAD:
   - Las contraseñas NUNCA se almacenan en texto plano
   - Se usa SHA-256 con salt para hashear contraseñas
   - Los tokens tienen firma criptográfica para prevenir manipulación
   - Los tokens expiran después de 24 horas
   - Hay un cache de tokens válidos para validación rápida

================================================================================
                          2. SERVIDOR TCP
================================================================================

El servidor TCP maneja todas las peticiones HTTP/REST de la aplicación.

FUNCIONAMIENTO:

1. INICIO (TCPServer.java):
   - Se crea un ServerSocket en el puerto 8081 (por defecto)
   - Se inicializa la base de datos MySQL
   - Se crea un ThreadPool para manejar múltiples clientes simultáneamente
   - El servidor entra en un bucle infinito esperando conexiones

2. CONEXIÓN DE CLIENTE:
   - Cuando un cliente se conecta, se acepta el Socket
   - Se crea un TCPClientHandler en un thread separado
   - Cada cliente tiene su propio handler independiente
   - Esto permite manejar múltiples clientes al mismo tiempo

3. PROCESAMIENTO DE PETICIONES (TCPClientHandler.java):
   - Lee la petición HTTP completa (método, path, headers, body)
   - Parsea la petición HTTP manualmente
   - Identifica la ruta y el método HTTP
   - Enruta a diferentes handlers según el path:
     * /api/auth/* → handleAuthRequest() (login, registro)
     * /api/users → handleUserRequest() (obtener usuarios)
     * /api/tasks/* → handleTaskRequest() (CRUD de tareas)
   - Valida el token para rutas protegidas
   - Procesa la petición y genera respuesta HTTP
   - Envía la respuesta al cliente
   - Cierra la conexión

4. PROTOCOLO HTTP:
   - El servidor implementa HTTP/1.1 básico
   - Soporta métodos: GET, POST, PUT, DELETE, OPTIONS
   - Maneja CORS para permitir peticiones desde el frontend
   - Las respuestas son en formato JSON
   - Headers estándar: Content-Type, Content-Length, Access-Control-*

5. VENTAJAS:
   - Conexión confiable (garantiza entrega de datos)
   - Orden de mensajes garantizado
   - Manejo de errores integrado
   - Ideal para operaciones CRUD y autenticación

================================================================================
                          3. SERVIDOR UDP
================================================================================

El servidor UDP maneja notificaciones en tiempo real para los usuarios.

FUNCIONAMIENTO:

1. INICIO (UDPServer.java):
   - Se crea un DatagramSocket en el puerto 8082 (por defecto)
   - El servidor entra en un bucle esperando mensajes UDP
   - Mantiene un registro de clientes conectados (userId → dirección IP:puerto)

2. REGISTRO DE CLIENTES:
   - Los clientes se registran enviando: "REGISTER:userId"
   - El servidor guarda la dirección IP y puerto del cliente
   - Responde con: "REGISTERED:OK"
   - Esto permite saber dónde enviar notificaciones a cada usuario

3. NOTIFICACIONES:
   - Cuando ocurre un evento (tarea asignada, creada, actualizada, eliminada)
   - El servidor busca el userId en el registro de clientes
   - Si está registrado, envía un paquete UDP con la notificación
   - La notificación es un JSON con: type, timestamp, taskId, taskTitle, task
   - El cliente recibe la notificación en tiempo real

4. TIPOS DE NOTIFICACIONES:
   - task_created: Nueva tarea creada
   - task_updated: Tarea actualizada
   - task_assigned: Tarea asignada a un usuario (la más importante)
   - task_deleted: Tarea eliminada

5. VENTAJAS:
   - Comunicación en tiempo real (sin polling)
   - Bajo overhead (no mantiene conexión abierta)
   - Ideal para notificaciones push
   - Permite notificar a múltiples usuarios simultáneamente

6. DESVENTAJAS:
   - No garantiza entrega (puede perderse un paquete)
   - No garantiza orden
   - El cliente debe estar registrado para recibir notificaciones

================================================================================
                   4. DESCRIPCIÓN DE ARCHIVOS JAVA
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│ SERVIDOR (server/)                                                          │
└─────────────────────────────────────────────────────────────────────────────┘

• TCPServer.java
  Propósito: Servidor TCP principal que escucha en el puerto 8081
  - Acepta conexiones de clientes
  - Crea handlers para cada cliente en threads separados
  - Inicializa la base de datos
  - Coordina con el servidor UDP

• TCPClientHandler.java
  Propósito: Maneja cada conexión TCP individual
  - Parsea peticiones HTTP
  - Enruta a diferentes handlers según el path
  - Valida tokens de autenticación
  - Procesa operaciones CRUD de tareas
  - Genera respuestas HTTP en formato JSON
  - Envía notificaciones UDP cuando es necesario

• UDPServer.java
  Propósito: Servidor UDP para notificaciones en tiempo real
  - Escucha en el puerto 8082
  - Registra clientes (userId → dirección IP:puerto)
  - Envía notificaciones a usuarios específicos
  - Maneja registro/desregistro de clientes

┌─────────────────────────────────────────────────────────────────────────────┐
│ SERVICIOS (service/)                                                        │
└─────────────────────────────────────────────────────────────────────────────┘

• AuthService.java
  Propósito: Lógica de negocio para autenticación
  - Registra nuevos usuarios
  - Valida credenciales en login
  - Genera tokens de autenticación
  - Valida tokens
  - Obtiene información de usuarios

• TaskService.java
  Propósito: Lógica de negocio para tareas
  - Crea nuevas tareas
  - Obtiene tareas de un usuario
  - Actualiza tareas
  - Elimina tareas
  - Valida permisos (solo el creador puede modificar)

┌─────────────────────────────────────────────────────────────────────────────┐
│ ACCESO A DATOS (dao/)                                                       │
└─────────────────────────────────────────────────────────────────────────────┘

• UserDAO.java
  Propósito: Acceso a datos de usuarios en MySQL
  - CRUD completo de usuarios
  - Búsquedas por ID, username, email
  - Validación de existencia
  - Obtiene todos los usuarios

• TaskDAO.java
  Propósito: Acceso a datos de tareas en MySQL
  - CRUD completo de tareas
  - Búsquedas por ID, usuario, estado
  - Maneja asignaciones (tabla task_assignments)
  - Carga información relacionada (creador, usuarios asignados)

┌─────────────────────────────────────────────────────────────────────────────┐
│ MODELOS (model/)                                                            │
└─────────────────────────────────────────────────────────────────────────────┘

• User.java
  Propósito: Modelo de datos para usuarios
  - Representa un usuario en el sistema
  - Campos: id, username, email, password, firstName, lastName
  - Método toJson() para serialización

• Task.java
  Propósito: Modelo de datos para tareas
  - Representa una tarea en el sistema
  - Campos: id, title, description, status, category, createdBy, etc.
  - Lista de usuarios asignados (assignedUsers)
  - Método toJson() para serialización

• TaskStatus.java
  Propósito: Enum con los estados posibles de una tarea
  - PENDING: Pendiente
  - IN_PROGRESS: En progreso
  - COMPLETED: Completada
  - CANCELLED: Cancelada

┌─────────────────────────────────────────────────────────────────────────────┐
│ UTILIDADES (util/)                                                          │
└─────────────────────────────────────────────────────────────────────────────┘

• TokenUtil.java
  Propósito: Generación y validación de tokens JWT-like
  - Genera tokens con userId, username, expiration y firma
  - Valida tokens (expiración, firma)
  - Mantiene cache de tokens válidos
  - Codifica/decodifica en Base64

• PasswordUtil.java
  Propósito: Manejo seguro de contraseñas
  - Hashea contraseñas con SHA-256 + salt
  - Verifica contraseñas sin almacenar texto plano
  - Genera salts únicos para cada contraseña

• JsonUtil.java
  Propósito: Parseo y generación de JSON (sin librerías externas)
  - Parsea JSON simple a Map
  - Convierte Map a JSON
  - Parsea JSON a objetos Task
  - Convierte listas de objetos a JSON arrays
  - Escapa caracteres especiales

┌─────────────────────────────────────────────────────────────────────────────┐
│ CONFIGURACIÓN (config/)                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

• DatabaseConfig.java
  Propósito: Configuración y conexión a MySQL
  - Establece conexión con la base de datos
  - Inicializa tablas si no existen
  - Maneja pool de conexiones
  - Cierra conexiones correctamente

┌─────────────────────────────────────────────────────────────────────────────┐
│ CLIENTES (client/) - Solo para pruebas                                     │
└─────────────────────────────────────────────────────────────────────────────┘

• TCPClient.java
  Propósito: Cliente de prueba para hacer peticiones HTTP al servidor TCP
  - Útil para testing y debugging
  - No se usa en producción

• UDPClient.java
  Propósito: Cliente de prueba para recibir notificaciones UDP
  - Útil para testing y debugging
  - No se usa en producción

================================================================================
                        FLUJO COMPLETO DE UNA PETICIÓN
================================================================================

1. Cliente (Frontend Angular) hace petición HTTP → Servidor TCP (puerto 8081)

2. TCPServer acepta conexión y crea TCPClientHandler en thread separado

3. TCPClientHandler:
   - Parsea petición HTTP
   - Extrae token del header Authorization
   - Valida token con TokenUtil
   - Enruta según path (/api/tasks, /api/auth, etc.)

4. Si es operación de tareas:
   - TaskService ejecuta lógica de negocio
   - TaskDAO accede a MySQL
   - Se retorna respuesta JSON

5. Si hay asignación de usuarios:
   - Se envía notificación UDP a cada usuario asignado
   - UDPServer busca el usuario en registro de clientes
   - Envía paquete UDP con notificación JSON

6. Cliente recibe respuesta HTTP y notificación UDP (si aplica)

================================================================================
                          RESUMEN DE PUERTOS
================================================================================

• Puerto 8081: Servidor TCP (HTTP/REST API)
• Puerto 8082: Servidor UDP (Notificaciones en tiempo real)

================================================================================
                          BASE DE DATOS
================================================================================

• MySQL en localhost
• Base de datos: kodeotask
• Tablas principales:
  - users: Usuarios del sistema
  - tasks: Tareas creadas
  - task_assignments: Relación muchos-a-muchos (tareas ↔ usuarios asignados)

================================================================================

